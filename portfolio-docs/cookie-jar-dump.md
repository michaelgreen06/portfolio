Cookie Jar is an idea that originated at Raid Guild a few years ago. There have been a few attempts to create the project at raid guild but none of them resulted in a project that was ready for consumers to use to easily create cookie jars and share them w/ teams. The most recent version was over engineered then when funding ran out for the project there wasn’t enough incentive to get it finished. There was interest in the project from gitcoin/allo.capital and they made their own version of cookie jar but it wasn’t super user friendly and required technical skills for users to create their own cookie jars. The purpose of this version of cookie jar V3 was to make an MVP of the product that worked on multiple chains, worked w/ ERC20 tokens as well as eth, was more user friendly, enabled anyone to easily create their own cookie jars and had a sustainable revenue model 1% fee on all funds deposited into jars. We wanted to get the product finished and launched as soon as possible because there was a lot of interest in the project generated by the Kevin Owocki during the Allo summoning and we wanted to get the product out while there was strong interest. Trying to get the product out the door as soon as possible so we could see how people use it so we could determine what the actual important things are.


I just completed the cookie jar project I’ve been working on full time for the last month. I started working on this project in March. The idea at that time was someone else would build the smart contracts for the app and then would make a very minimal frontend for the app using scaffold eth. After that was complete the plan was for me to come in and design and implement a ux on top of the smart contracts so anyone could easily create a cookie jar. What ended up happening is the person who was supposed to make the smart contracts and simple front end for the app ended up creating a frontend in tandem w/ building the smart contracts. Working together with him was quite challenging there were always communication issues and effective collaboaration was nearly impossible.  because whenever I would try to contribute or ask how I could contribute I was always told to wait a little until it is finished then he would show it to me. It was very challenging to work with him because his work was often in private repos and he was very bad at communicating which branches he was working on / were active. We later found out that he had an entire team working on the project with him. 
This arrangement continued for weeks until we missed the 1st launch deadline for the app at which point he finally gave us the most up to date code so we could finish the work on the app to launch it and we discontinued working with him and his team. 

Indexing vs writing on chain
    The way the contracts were initially designed used on chain data instead of indexing events emmited from the contracts. There was a registry contract that received data from the factory contract. We eliminated the registry contract because it was not essential at all and just wrote and read the relevant info from the factory contract. We stuck with writing and reading data on chain, even though we know indexing would be a much better setup, because this is how the smart contracts were already designed and our goal was to get this product out the door as soon as possible and we thought it would take a lot longer to switch to indexing. 
Wagmi hooks – 
I learned a lot about wagmi hooks. They are a super powerful and dev friendly way to work with the ABI from smart contracts. It was surprising to learn that the code we got came w/ wagmi hooks but didn’t even have a  wagmi.config file so I learned how to set that up and did so we could regenerate the hooks off the updated smart contracts. 
I also learned how incredibly powerful it is to add documentation for packages into my codebase so the AI tools in my IDE could reference the documentation and produce code that is as up to date as possible. I am excited to try out an MCP (Context7) on my next project that has all the most current documentation provided. The way I brought the docs for rainbow kit and wagmi into the project was pretty annoying because I had to add them to my .gitignore file because I didn’t want them in the repo (there were over 300 files total), but had to remove them from the .gitignore file and restart the IDE when I wanted the AI tools to have access to the documentation. 
We were given Spaghetti code –
 w/ tons of unused code/files etc – also tons of things that would normally be there in a coherent project weren’t there (abis, wagmi.config etc) Display values were hardcoded into components instead of using the theme file (the project had tailwind but it wasn’t utilized efficiently) which made it harder to adjust things and created problems for simple things like dark mode because components weren’t theme aware. There were pages that were started and never finished then functionality was inserted in other places. EG there was an admin page that wasn’t used and there was an admin component in individual jar pages. The code Didn’t conform to the original specs – not super mobile friendly (it works but it’s ugly and a bad ux). There was a bunch of unnecessary stuff like a whole documentation section that talked about things that didn’t even exist like the cookie jar SDK. It’s clear that a lot of the codebase was sloppy AI generated code. 
The app we got was only setup to work w/ eth on one chain
    Had hardcoded values for only 1 chain and only worked with eth – I configured it for multi chain setup w/ erc20s and using token decimals and symbols so it was more user friendly where the user could just enter the amount of tokens they wanted to use and didn’t need to know the token decimals and enter things in a super unfriendly format. 

I was the primary driver of the project once we were able to take over the code base and had really great support from Rowdy who was a core contributor on the 2nd raid guild version of cookie jar. Also brought on liron to audit and finish / fix up the smart contracts. I made 99% of the issues and made the decisions of what needed to be done and what needed to be prioritized for the MVP launch – making lots of product decisions. I was Constantly cutting things out that weren’t essential / getting it to a place where it is usable – admin filter on jars overview page vs profile page that only showed jars if I was an admin (the profile page should have showed all jars not just jars I was an admin of) 
We did extensive testing of the app before full production deployement and we caught some pretty important things during testing. We were taking 0.01% instead of 1% fee. The emergency withdrawal feature wasn’t working in the ui. 
the token utilities function I created was used many places throughout the app and was essential for compatibility w/ erc20 tokens especially integrating them in a user friendly way


I learned how to deploy factory contracts. This is the script I used: 
`source .env && forge script script/Deploy.s.sol:Deploy \
  --via-ir \
  --rpc-url $BASE_SEPOLIA_URL \
  --broadcast \
  --verify \
  --etherscan-api-key $BASE_ETHERSCAN_KEY \
  --verifier-url https://api-sepolia.basescan.org/api \
  --chain-id 84532 \
  -vvvv`


Improvements that were excluded for MVP that could be useful in th future
Show all jars I’m eligible for on 1 page w/o making me switch networks
Add whitelist during jar creation


Moving forward if I work on this project more I would want to follow the lean canvas / running lean framework to make sure we are evaluating this specific capital allocation problem correctly and trying to solve the right problem instead of falling in love w/ our current solution. For any big ux changes it would actually probably be a lot easier to start over from scratch because this current ui/ux is built on top of very sloppy code. 
